# Introduction

## What is web atoms?

"Web Atoms" is an light weight advanced MVVM & MVU framework to write web applications in `HTML5`. Using JavaScript modules, you can divide large app into smaller modules, also offer localization using modules with reduced app size.


## Requirements

1. VS Code
2. TSLint extension
3. NodeJS with NPM
4. Visual Studio for Xamarin.Forms app [optional]
5. Gitlense [optional]

## UMD Loader

All web atoms modules are written (transpiled) as UMD module, suitable for testing in node as well as to load in browser with AMD Loader.

```html
<html>
    <head>
        <title>Web Atoms Core Samples</title>
        <!-- AMD Loader -->
        <script type="text/javascript" src="./node_modules/web-atoms-amd-loader/umd.js"></script>
    </head>
    <body>
        <script type="text/javascript">

            // map path of Application Package
            // all dependencies will be loaded from
            // node_modules folder inside Application Package
            UMD.setupRoot("@web-atoms/samples", "./");

            // set language
            UMD.lang = "en-US";

            // Load view in entire page, this method will
            // resolve package from the above mentioned map of 
            // package to url. And it will create an instance of
            // App class and it will host the view `AppHost` in the
            // body of this document
            UMD.loadView(
                /** Path to module (node resolution style) */
                "@web-atoms/samples/dist/web/views/AppHost",
                /** Design Mode to enable mock*/
                false /*true*/);
        </script>
    </body>
</html>
```

> To pack and load all modules at once, please review `Packer`.

## Directory structure

```
root
  + dist // dynamically generated by compilation, ignored in git
      ...
  + src
     + model        // all models here
     + services     // all services inside this folder
     + tests        // all unit tests
     + view-models  // all view models must be placed here
     + web          // all tsx files must be placed inside web folder
```

## Startup

1. Install Visual Studio Code
2. Install Node with NPM
3. Start VS Code and create a new terminal
4. Run `npm install -g @web-atoms/pack @web-atoms/dev-server`
5. Clone repository https://github.com/web-atoms/intro and rename package name in package.json, this will configure all tasks needed to run web atoms.
6. Run VS Code tasks and run `All Build`
7. This will start a small web server, you can open the displayed link in browser and all views will be displayed to test.

## AtomControl

AtomControl is a UI control which contains logic to render visual elements on the screen. AtomControl has an initialization lifecycle that is common in every platform. In `Web Browser`, it has special lifecycle to render contents. Most of the time developer does not need to worry about it as controls are created with best performance in mind.

Following properties exist on AtomControl and they are **Logically Inherited**. 

### Properties

* app (readonly)
* parent (readonly)
* data
* viewModel
* localViewModel

### Why data and viewModel properties are separate?

In most of UI framework, view model is usually set in `data` property, which leads to problems in multiple items control such as list box etc. That requires unnecessary climbing up hierarchy and get instance of parent's data property to bind. So having separate inherited `viewModel` property makes it easier to reference viewModel associated with whole page or fragment.

### What is localViewModel ?

To make reusable components easier, `localViewModel` can be used to host all logic that is only specific to the component. For example, lets say you want to create a calendar component. Local view model will contain all the logic to create list of all dates for currently displayed month and year. It will also create list of all years. All this logic will be independent of rendering logic and it can be put inside a view model which can be unit tested separately. Benefit here is, you can write a reusable view model for platform dependent component that has common logic across different platforms. So inside component, you will only write binding expressions to `localViewModel`.

## AtomViewModel

`AtomViewModel` class provides necessary services and properties to write easily extensible view models. It has `init` and `dispose` methods to initialize and dispose your view model.

```typescript
export default class TaskListViewModel extends AtomViewModel {

    // dynamically inject TaskService
    @Inject
    public taskService: TaskService;

    public tasks: ITaskModel[];

    @Load({ init: true })
    public async loadTasks(ct?: CancelToken): Promise<void> {
        this.tasks = await this.taskService.loadTasks(ct);
    }
}
```

### Watch

Since view model does not have access to user interaction updates, View usually does two way binding to a property and when it is modified by user, we have to watch for changes and update view model. It is done via `@Watch` decorator.

```typescript
export default class TaskListViewModel extends AtomViewModel {

    @Inject
    public taskService: TaskService;

    public tasks: ITaskModel[];

    public search: string = null;

    public range = { start: 0, size: 10 };

    // whenever any of search, range.start or range.size 
    // property is modified
    // automatically call this method
    @Load({ init: true })
    public async loadTasks(ct?: CancelToken): void {
        const search = this.search;
        const start = this.range.start;
        const size = this.range.size;
        this.tasks = 
            await this.taskService.loadTasks(
                search, start, size, ct);
    }
}
```
By convention, `@Load` decorated method must be prefixed with `load` word. Even if it is named differently, `@Load` decorator will still watch for changes.

Load decorator will execute method when `init` is `true`, and it will watch for any changes for property path starting with `this` when `watch` is set to `true`.

This decorator automatically starts watching every expression that starts with `this.`, it ignores methods and it watches only properties. For performance, this decorator does not parse javascript code, it only looks for `this.identifier.identifier...` expression and creates map of watching every single property in entire expression.

>  Every property accessed inside `@Load({ watch: true })` decorated method must be initialized to `non undefined` value. Since binding framework ignores `undefined`

### Watch property

In order to update a readonly property, you can set `@Watch` on getter method, this will cause Binding Framework to update UI element bound to this property.

```typescript

    @Watch
    public get fullName(): string {
        return `${ this.model.firstName } ${ this.model.lastName }`;
    }

```

HTML
```typescript
    <span text={Bind.oneWay( () => this.viewModel.fullName )}></span>
```

You can bind any view property to `fullName` and it will refresh automatically whenever any changes was detected in `model.firstName` or `model.lastName`. Again, both must not initialized to `undefined`.

### Watch Async Property

Watch can also be applied on a readonly property that returns a promise, but you cannot mark get method as `async`

```typescript

    @Watch
    public get messageList(): Promise<IMessage[]> {
        return this.messageService.getList(
            this.searchText,
            this.archived
            );
    }

```

Now when you bind `messageList` to `items` property of `AtomItemsControl`, it will automatically refresh whenever any property mentioned in the method changes.

### Validate decorator

Though `@Watch` is great way to watch any property, we cannot use it for validation because as soon as page is loaded, user will be thrown with error messages. So we have created `@Validate` decorator which only returns an error message after `this.isValid` property is called.

For example,

```typescript

export default class SignupViewModel extends AtomViewModel {

    @Inject
    public navigationService: NavigationService;

    public model = {
        firstName: null,
        lastName: null
    };

    // both validate properties will return undefined value
    // unless `this.isValid` is referenced.

    @Validate
    public get errorFirstName(): string {
        return this.model.firstName ? "" : "First name is required";
    }

    @Validate
    public get errorLastName(): string {
        return this.model.firstName ? "" : "Last name is required";
    }

    /** This decorator will validate all error properties
     * and it will execute method only if there are no validation
     * errors.
     */
    @Action({ validate: true })
    public signup(): Promise<void> {
        // do signup...
    }

}

```
HTML
```typescript

export default class Signup extends AtomControl {

    /** This enables intellisense, do not initialize this*/
    public viewModel: SignupViewModel;

    public create() {
        this.viewModel = this.resolve(SignupViewModel);

        this.render(<div>
        <AtomForm>
            <AtomField
                label="Username"
                error={Bind.oneWay(() => this.viewModel.errorUsername)}>
                <input
                    value={Bind.twoWays(() => this.viewModel.model.firstName)}/>
            </AtomField>
            <AtomField
                label="Password"
                error={Bind.oneWay(() => this.viewModel.errorPassword)}>
                <input
                    type="password"
                    value={Bind.twoWays(() => this.viewModel.model.password)}/>
            </AtomField>
            <AtomField>
                <button
                    eventClick={Bind.event(() => this.viewModel.signup())} 
                    text="Signup"/>
            </AtomField>
        </AtomForm>
        </div>);
    }

}
```

In above example, when page is loaded, error spans will not display anything. Even if `firstName` and `lastName` both are empty. As soon as user clicks `Signup` button, `this.isValid` get method will start watching for changes in all `@Validate` decorator methods and user interface will start displaying error message.

